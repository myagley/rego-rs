use ordered_float::NotNan;

use crate::Location;
use crate::lexer::Error;
use crate::token::{StringLiteral, Token};

grammar<'input>(input: &'input str);

extern {
    type Location = Location;
    type Error = Error;

    enum Token<'input> {
        "as" => Token::As,
        "default" => Token::Default,
        "else" => Token::Else,
        "false" => Token::False,
        "import" => Token::Import,
        "not" => Token::Not,
        "null" => Token::Null,
        "package" => Token::Package,
        "set" => Token::Set,
        "some" => Token::Some,
        "true" => Token::True,
        "with" => Token::With,

        "integer-literal" => Token::IntLiteral(<i64>),
        "float-literal" => Token::FloatLiteral(<NotNan<f64>>),
        "string-literal" => Token::StringLiteral(<StringLiteral<'input>>),

        "id" => Token::Identifier(<&'input str>),

        "=" => Token::Equal,
        "==" => Token::EqualEqual,
        "!=" => Token::NotEqual,
        "<" => Token::Less,
        "<=" => Token::LessEqual,
        ">" => Token::Greater,
        ">=" => Token::GreaterEqual,
        "+" => Token::Plus,
        "-" => Token::Minus,
        "*" => Token::Star,
        "/" => Token::Slash,
        "&" => Token::Amper,
        "|" => Token::Vbar,

        "(" => Token::ParenOpen,
        ")" => Token::ParenClose,
        "[" => Token::BracketOpen,
        "]" => Token::BracketClose,
        "{" => Token::BraceOpen,
        "}" => Token::BraceClose,

        "\n" => Token::Newline,
        "\r" => Token::CarriageReturn,
        ";" => Token::SemiColon,
        ":" => Token::Colon,
        "," => Token::Comma,
        "." => Token::Dot,
        "_" => Token::UnderScore,
        ":=" => Token::Assign,
    }
}

Comma<T>: () = {
    (T ",")* T?
};

pub Module: () = Package Import* Policy;

Import: () = "import" Ref ("as" Var)? ";"+;

Package: () = "package" Ref ";"+;

Policy: () = Rule*;

Rule: () = {
    "default"? RuleHead RuleBody* ";"+
};

RuleHead: () = {
    Var ( "(" Comma<Term> ")" )? ( "[" Term "]" )? ( AssignOrEqual Term )?
};

#[inline]
AssignOrEqual: () = {
    ":=",
    "=",
};

RuleBody: () = {
    ( "else" ( "=" Term)?)? "{" Query "}",
};

pub Query: () = {
    Literal ( ";"+ Literal )* ";"?
};

#[inline]
Newline: () = {
    "\r" "\n",
    "\n",
}

Literal: () = {
    LiteralTarget WithModifier?
}

#[inline]
LiteralTarget: () = {
    Expr,
    SomeDecl,
    "not" Expr,
};

WithModifier: () = {
    "with" Term "as" Term,
};

SomeDecl: () = {
    "some" Comma<Var>,
};

Expr: () = {
    (Term AssignOrEqual)? Tier0,
};

Tier<Op, NextTier>: () = {
    Tier<Op, NextTier> Op NextTier,
    NextTier,
};

Tier0 = Tier<Tier0Op, Tier1>;
Tier1 = Tier<Tier1Op, Tier2>;
Tier2 = Tier<Tier2Op, Tier3>;
Tier3 = Tier<Tier3Op, Term>;

Tier3Op: () = {
    "*",
    "/",
    "&",
    "|",
};

Tier2Op: () = {
    "+",
    "-",
};

Tier1Op: () = {
    "<",
    "<=",
    ">",
    ">=",
};

Tier0Op: () = {
    "==",
    "!=",
};

Ref: () = {
    RefTarget RefArg*,
};

#[inline]
RefTarget: () = {
    Var,
    Array,
    ArrayCompr,
    Object,
    ObjectCompr,
    Set,
    SetCompr,
};

#[inline]
RefArg: () = {
    RefArgDot,
    RefArgBrack,
};

#[inline]
RefArgBrack: () = {
    "[" RefArgBrackParam "]"
};

#[inline]
RefArgBrackParam: () = {
    Scalar,
    Var,
    Array,
    Object,
    Set,
    "_",
};

#[inline]
RefArgDot: () = {
    "." Var
};

// There is some ambiguity in the grammar
// The left hand side should be Var ("." Var)*.
// This conflicts with Ref
ExprCall: () = {
    Ref "(" Comma<Term> ")"
};

Term: () = {
    Ref,
    Scalar,
    ExprCall,
    "(" <Expr> ")",
};

ArrayCompr: () = "[" Term  "|" Query "]";

SetCompr: () = "{" Term "|" Query "}";

ObjectCompr: () = "{" ObjectItem "|" Query "}";

Array: () = "["  Comma<Term> "]";

Set: () = {
    NonEmptySet,
    EmptySet,
};

NonEmptySet: () = {
    "{" (Term ",")* Term "}"
}

EmptySet: () = "set" "(" ")";

Object: () = "{" Comma<ObjectItem> "}";

ObjectItem: () = ObjectKey ":" Term;

#[inline]
ObjectKey: () = {
    Scalar,
    Ref,
};

Var: () = "id";

Scalar: () = {
    String,
    Number,
    Bool,
    "null",
};

Bool: () = {
    "true",
    "false",
};

String: () = {
    "string-literal"
};

Number: () = {
    "integer-literal",
    "float-literal",
};
